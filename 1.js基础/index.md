![主体链接](https://juejin.cn/post/6844904116339261447#heading-1)

# JS基础

![JS基础简图](https://gitee.com/M-cheng-web/map-storage/raw/master/vue-img/71e30bdc18b44272b5fa0e16b9c3f2e8_tplv-k3u1fbpfcp-watermark.webp)

## 执行上下文/作用域/闭包
### 介绍JS的执行上下文
> 有三种执行上下文类型<br>
> 1.全局执行上下文-基础的上下文,任何不在函数内部的代码都在全局上下文中 会执行两件事: 创建一个全局的 window 对象(浏览器情况下), 并且设置this 的值等于这个全局对象.一个程序中只会有一个全局执行上下文<br>
> 2.函数执行上下文-每当一个函数被调用时,都会生成一个函数执行上下文,然后 这个函数执行上下文会执行这个函数<br>
> 3.Eval函数执行上下文-执行Eval函数时也会生成属于它的执行上下文
### 介绍JS的执行栈
> 是一种后进先出的数据结构,被用来存储执行上下文<br>
> 当程序开始运行时,会将全局执行上下文压入栈底,随后在代码运行中发现新的 需要执行的函数,就会生成这个函数的上下文并放入执行栈中并执行这个函> 数 如果这个函数内也有需要执行的函数,会继续生成并放入. 当没有可以继续生成的函数上下文时或者是函数已经执行完毕,会将这个函数 从执行栈中弹出
### 介绍JS的作用域/作用域链
> 作用域<br>
> 作用域规定了如何查找变量,也就是确定当前执行代码对变量的访问权限,JS采用词法作用域,也就是静态作用域

> 静态作用域与动态作用域<br>
> 静态作用域中的函数作用域在函数定义的时候就决定了<br>
> 动态作用域中的函数作用域在函数调用的时候才决定
``` js
var value = 1;
// 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有
// 就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1
function foo() {
  console.log(value);
}
function bar() {
  var value = 2;
  foo();
}
bar(); // 1
```

> 为什么函数作用域在函数定义的时候就决定了<br>
> 这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，可以理解 [[scope]] 就是所有父变量对象的层级链
``` js
function foo() {
  function bar() {
    ...
  }
}
// 函数创建时,各自的[[scope]]为:
foo.[[scope]] = [
  globalContext.VO
];
bar.[[scope]] = [
  fooContext.AO,
  globalContext.VO
];
```

> 作用域链<br>
> 当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找<br>
> 一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链
### 介绍JS的闭包是什么以及应用场景
> 闭包是什么<br>
> 是一个可以访问外部作用域中变量的内部函数,这些被引用的变量直到闭包被销毁时才会被销毁

> 应用场景<br>
> 私有变量,工程函数,vue中watch监听,promise等等


## this/call/apply/bind
### 介绍JS里的this
> this为当前的执行环境，根据this可以拿到属性和函数<br>
> 分为全局this和函数中的this<br>
> 全局的this指向它本身，没有复杂的情况考虑<br>
> 函数的this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的<br>
> 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象

### 如何改变this指向
> call，apply，bind，以及箭头函数<br>
> call和apply功能一样，只是传参的方式不一样，一个接收多个字符串，一个接收数组，bind会返回函数并不是运行<br>
> 箭头函数是在函数创建时就会绑定确定函数内容中的this指向，而不是在运行时确定

### 如何实现call和apply,bind

## 原型/继承
这里看JS高设的笔记都有(包括关于原型链的一些问题以及解决方法，必看！！)
### 介绍JS的原型
### 原型链是什么
### 如何利用原型实现继承

## Promise
自己笔记里都写了,到时候总结一下
### Promise是什么
### 如何实现一个Promise(Promise A+)
### async await

## 深浅拷贝
参考手写
### 介绍JS的深浅拷贝
### 如何实现浅拷贝
### 如何实现深拷贝
### 实现深拷贝需要注意哪些问题
### 如何解决循环引用的问题

## 事件机制/Event Loop
### 如何实现一个事件的发布订阅
### 介绍事件循环
> JS是单线程的并且JS单线程执行方式是基于事件循环的,因为它在执行任务的时候会产生一个任务队列<br>
> 这个任务队列是先进先出的,分为宏任务和微任务,在遇到异步事件时会将事件先存入这个任务队列,在同步事件<br>
> 都完成后才会开始执行任务队列,当这个任务队列里还存在异步事件还会接着存入任务队列,这个过程就是事件循环
### 宏任务和微任务有什么区别
> 宏任务与微任务都是异步队列,区别在于微任务比宏任务的优先级高,如果是在同一层级的话微任务是会在任务队列的最前面
> 宏任务会在最后面,比如setTimeOut,setInterVal, 微任务比如Promise

## 函数式编程
### 函数柯里化
``` js
var person = [{name: 'kevin'}, {name: 'daisy'}]
curry = function(fn) {
  return function(key) {
    return (item) => item[key];
  }
}
var prop = curry(function (key, obj) {
  return obj[key]
});
var name = person.map(prop('name'))
console.log('name', name); // kevin,daisy
```

## service worker

## web worker

## 常用方法
### 数组方法
### ES6后的